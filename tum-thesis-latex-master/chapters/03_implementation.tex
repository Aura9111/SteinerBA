% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Implementation}\label{chapter:implementation}

\section{MST-Algorithm}

To implement the MST-Algorithm we first build the metric closure $\bar{G}$ of the input Graph $G$. Then we take the subgraph $\bar{G}_T$ of this metric closure containing all required terminal nodes $T$. Using the subgraph as input for a minimum spanning tree algorithm, we receive a tree which now consists of only terminals and edges, that represent the shortest paths between them. In this implementation we are going to use Joseph Kruskal's minimum spanning tree algorithm \cite{kruskal1956shortest}, since it's simple, intuitive and is also easily reusable for building the minimum spanning forest we need to compute the loss of a Steiner tree. The final step is for us to replace the edges of the tree by the corresponding shortest paths in G and the outcome is our Steiner tree approximation.

\section{Berman-Ramaiyer-Algorithm}

The approximation algorithm by Berman and Ramaiyer is split into two phases which both maintain a spanning tree $M$ of $T$, which is initialized to the output of our MST-Algorithm. The first phase is called the evaluation phase and it uses the $prepareChange$ procedure, which we are going to look at shortly, to compute two sets of edges called the Add-Set $A$ and the Remove-Set $R$ for every $j$-element subset $\tau \subseteq T$, with $j$ being increased up to a maximum size bounded by the input number $k$. It then uses these sets to compute a $gain$ of $\tau$, by subtracting the cost of a SMT($\tau$) from the cost of the Remove-Set. If this $gain$ is greater than zero the Remove-Set is removed from M and every edge of the Add-Set has its cost reduced by $gain$ and is added to $M$ right afterwards. This marks a tentative preference to add SMT($\tau$). The subset $\tau$, the Remove-Set $R$ and the Add-Set $A$ are added to a stack $\sigma_j$ to be read in the construction phase.
\begin{figure}[htbp]
  \centering
  \begin{tabular}{c}
  \begin{lstlisting}[mathescape]
M = SMT(T)
for j=3 to k {											
  $\sigma_j$=$\emptyset$								
}													
for j=3 to k {											
  for each j-element subset $\tau$ $\subseteq$ T {			
    prepareChange(M, $\tau$, R, A);						
    gain= cost(R) - smt($\tau$);					
    if gain>0 {									
      Decrease the cost of each edge if A by $\textit{gain}$;
      M = M $\backslash$ R $\cup$ A
      $\sigma_j$.push($\tau$, R, A);
    }
  }
}
    }
  \end{lstlisting}
  \end{tabular}
  \caption[evaluation]{Evaluation Phase from Berman, Ramaiyer (Fig.2 \cite{BeRa94})}\label{fig:evaPseudo}
\end{figure}

The construction phase works on the output of the evaluation phase and starts by initializing the second spanning tree $N$, which will end up being the submitted solution, with the current version of $M$. It moves through the stacks $\sigma_j$ in opposite direction and pops entries from it until the stack is empty. Every entries data is used to revert the changes made to $M$ by subtracting the Add-Set and adding the Remove-Set. If all edges from the Add-Set are still present in $N$, they are removed and the SMT($\tau$) is added in their place. If there are only some but not all edges from $A$ remaining in $N$, each of these edges $e \subseteq (A\cap N)$ is replaced in $N$ with the minimal cost edge in $M$, that connects the two components created by removing $e$. After these changes have been applied for every entry of every stack the approximated minimal Steiner tree is present in $N$, while $M$ should have reverted to the original input of the evaluation phase, which was an MST-approximation of the minimal Steiner tree. 
TODO prepareChange
\section{Hougardy-Proemel-Algorithm}


